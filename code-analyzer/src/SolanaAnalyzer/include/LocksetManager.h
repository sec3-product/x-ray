#ifndef RACEDETECTOR_LOCKSETMANAGER_H
#define RACEDETECTOR_LOCKSETMANAGER_H

#include <map>
#include <set>

#include "PTAModels/GraphBLASModel.h"
#include "llvm/IR/Value.h"

namespace aser {

// forward declaration
class MemAccessEvent;

class LocksetManager {
public:
  using ID = uint32_t;

private:
  std::map<std::vector<const ObjTy *>, LocksetManager::ID> locksetToIdMap;
  std::map<LocksetManager::ID, std::vector<const ObjTy *>> idTolocksetMap;
  // NOTE: changed from std::set to vector
  // mainly for FP generated by PTA
  // for std::set, the (o1,...) stands for pts:
  // ```
  // lock l1 (o1, o2) => set{o1, o2}
  //   lock l2 (o2, o3) => set{o1, o2, o3}
  //   unlock l2 (o2, o3) => set{o1}
  // unlock l1 (o1, o2) => set{empty}
  // ```
  // the problem above is line3 accidently relase o2
  // due to the imprecision of pta (the pts has more than 1 object)
  //
  // for std::vector:
  // ```
  // lock l1 (o1, o2) => vec{o1, o2}
  //   lock l2 (o2, o3) => vec{o1, o2, o2, o3}
  //   unlock l2 (o2, o3) => vec{o1, o2}
  // unlock l1 (o1, o2) => vec{empty}
  // ```
  // this will make the example correct.
  //
  // an edge case that may fail for std::vector:
  // ```
  // lock l1 (o1, o2) => vec{o1, o2}
  //   lock l2 (o2, o3) => vec{o1, o2, o2, o3}
  //   unlock l2 (o2, o3) => vec{o1, o2}
  // unlock l1 (o1) => vec{o2}  BAD!!! long holding lock
  // ```
  // however, since our PTA is conservative, usually the lockset off l1 won't
  // mssing o2 therefore, the vector is a better option here
  std::vector<const ObjTy *> curLockset;
  ID curLocksetId;
  PTA &pta;
  std::set<const ObjTy *> *uniqueLocks = nullptr;
  std::set<const ObjTy *> rwLocks;
  // cache: maintain a map from lockStr to lock
  std::map<std::string, std::vector<const ObjTy *>> lockSetCache;
  std::map<std::vector<const ObjTy *>, std::set<std::string>>
      lockSetStringsCache;
  std::map<const llvm::Instruction *, std::string> lockStrInstCache;
  std::map<const llvm::Instruction *, const llvm::CallBase *> raiiLockInstCache;
  const llvm::CallBase *findRAIILockInst(const llvm::Instruction *inst);

  bool hasCommonLocks(const MemAccessEvent *e1,
                      const std::vector<const ObjTy *> &lockset1,
                      const MemAccessEvent *e2,
                      const std::vector<const ObjTy *> &lockset2) const;
  void dumpCurrentLockset(bool isLock, LocksetManager::ID id);
  bool isRWLock(const ObjTy *o) const;
  bool hasRWLockButOnlyRD(const MemAccessEvent *e) const;

public:
  LocksetManager(PTA &pta);
  void releaseLock(const ctx *context, const llvm::Instruction *I,
                   const llvm::Value *lockPtr);
  void acquireLock(const ctx *context, const llvm::Instruction *I,
                   const llvm::Value *lockPtr);
  bool sharesLock(const MemAccessEvent *e1, const MemAccessEvent *e2) const;
  ID getCurrentLocksetId() const;
  void addRWLock(const ctx *context, const llvm::Value *lockPtr);
  void resetCurLocksetAndId() {
    curLocksetId = 0; // empty lockset
    curLockset.clear();
  }
  void dumpLockset() {
    llvm::outs() << "\n========total #lock variables: " << lockSetCache.size()
                 << "========\n";
    llvm::outs() << "========total #locks: " << lockSetStringsCache.size()
                 << "========\n";

    for (auto &[lockset, lockStrings] : lockSetStringsCache) {
      for (auto o : lockset) {
        llvm::outs() << "lock: " << o->getValue() << "\n";
        for (auto s : lockStrings)
          llvm::outs() << "        name: " << s << "\n";
      }
    }
    llvm::outs() << "\n========total #locksets: " << idTolocksetMap.size()
                 << "========\n";

    for (auto &[id, lockset] : idTolocksetMap) {
      llvm::outs() << "lockset id: " << id << "\n";
      for (auto o : lockset) {
        llvm::outs() << "        lock: " << o->getValue() << "\n";
      }
    }
  };
  std::string findLockStr(const llvm::Instruction *I,
                          const llvm::Value *lockPtr);
  void getLockSet(const ctx *context, const llvm::Instruction *I,
                  const llvm::Value *lockPtr, std::vector<const ObjTy *> &pts);
  std::set<const ObjTy *> *getUniqueLocks() {
    if (uniqueLocks == nullptr) {
      uniqueLocks = new std::set<const ObjTy *>;
      for (auto &[id, lockset] : idTolocksetMap) {
        // llvm::outs() << "lockset id: " << id << "\n";
        for (auto o : lockset) {
          // llvm::outs() << "        lock: " << o->getValue() << "\n";
          uniqueLocks->insert(o);
        }
      }
    }
    return uniqueLocks;
  };

  LocksetManager::ID getRetrofitLockSetID(std::vector<const ObjTy *> pts,
                                          LocksetManager::ID id);
  std::vector<const ObjTy *> getLockSet(LocksetManager::ID id);

  bool hasDifferentPointsToSet(const ctx *ctx1, const llvm::Value *lockPtr1,
                               const ctx *ctx2, const llvm::Value *lockPtr2) {
    // assumption lockPtr1 and lockPtr2 are not null
    if (lockPtr1 == nullptr || lockPtr2 == nullptr)
      return true;
    else {
      std::vector<const ObjTy *> pts1;
      std::vector<const ObjTy *> pts2;
      pta.getPointsTo(ctx1, lockPtr1, pts1);
      pta.getPointsTo(ctx2, lockPtr2, pts2);

      if (pts1 == pts2) {
        // if we get here, something is interesting
        // llvm::outs() << "INTERESTING  UNLOCK: " << *lockPtr2 << "\n";

        return false;
      } else
        return true;
    }
  }
};

} // namespace aser

#endif