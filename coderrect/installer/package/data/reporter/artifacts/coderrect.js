// Customized JQuery default options
$.modal.defaults.showClose = false;

/**
 * Returns pure executable name of current report by inputting whole path 
 * of bc path.
 * 
 * For example, we get the bc file path by json file generated by racedetect is
 * "/home/coderrect/.coderrect/build/executable.bc", the output should be 
 * "executable"
*/
function getProjectPath(bcfilePath) {
    var idx = bcfilePath.lastIndexOf('/');
    //execlude ".bc" from bc file path
    var executableName = bcfilePath.substring(idx + 1, bcfilePath.length - 3)
    return executableName;
}


/**
 * Returns number of spaces between "22|" and the code.
 * 
 * For special lines such as "" or " 22|", we return 10000.
 *
 * @param line - it has the format of "22|        int a = 23;"
 */
function findLeadingSpaces(line) {
    if (line.length == 0)
        return 10000;

    // for lines such as " 232|"
    let re = /^\s\d+\|$/;
    if (re.test(line))
        return 10000;

    let num = 0;
    for (let i = 1; i < line.length; i++) {
        let ch = line.charAt(i);
        if (ch == ' ' || ch == '\t') {
            num++;
        }
        else {
            if (num != 0) break;
        }
    }

    return num;
}


/**
 * Returns a string whith 'numOfRemovedSpaces" of leading spaces are removed
 *
 * @param line - like '22|       int a = b;'
 */
function removeSpaces(line, numOfRemovedSpaces) {
    if (line.length == 0)
        return line;

    let loc = 1;
    for (loc = 1; loc < line.length; loc++) {
        if (line.charAt(loc) == ' ' || line.charAt(loc) == '\t') {
            break;
        }
    }
    loc++;
    let str = line.substring(0, loc);
    loc += numOfRemovedSpaces;
    str += line.substring(loc);

    return str;
}


/**
 * @param snippet - a mutli-line string. each line has the format
 *                  22|         int a = 2
 *                  where "22" is the line number
 * @return a string removed all unnecessary identions
 */
function removeUnnecessaryIdentions(snippet) {
    const lines = snippet.split(/\r?\n/);
    let minSpaces = 10000;
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const leadingSpaces = findLeadingSpaces(line);

        // if a line doesn't have enough leading spaces, we
        // don't need to optimize the whole snippet
        if (leadingSpaces <= 1)
            return snippet;

        if (leadingSpaces < minSpaces)
            minSpaces = leadingSpaces;
    }

    // keep one space betweek "22|" and the code
    const removedSpaces = minSpaces - 1;

    let buf = '';
    for (let i = 0; i < lines.length; i++) {
        const line2 = lines[i];
        buf += removeSpaces(line2, removedSpaces) + "\n";
    }

    return buf;
}

// convert symbols to escape symbols in HTML
// especially "<" and ">" in C++ code
// otherwise, they will be falsely displayed as HTML tags
function convertEscape(text) {
    return text.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}

// e.g., [/root/hello.rs:777] => [<a class='filepath'>/root/hello.rs:777<a>]
// FIXME: Is this always safe? will the raw text contain '[' or ']'?
function convertFilePath(text) {
    return text.replaceAll("[", "[<a class='filepath'>").replaceAll("]", "<a>]");
}

/**
 * @param race - json
 */
function setupOneRace(ord, race, isToctou) {
    var selector = "#race" + ord + " .race-no";
    $(selector).html("" + ord);

    if (isToctou) {
        selector = "#race" + ord + " .explanation";
        $(selector).text("The condition checked in an if statement is modified by another thread simultaneously. The condition may not hold for the entirety of the guarded branch.");
    }

    // set href to the source file
    selector = "#race" + ord + " .race-var .filepath";
    var el = $(selector);
    // FIXME: disable this for now, since we rarely click this to view source code
    // el.href = "file://" + race.sharedObj.filename;
    el.attr("href", "#race" + ord);
    el.html(race.sharedObj.dir + utils.getFileSep() + race.sharedObj.filename);

    // set line number
    selector = "#race" + ord + " .race-var-src .line-number";
    $(selector).html(race.sharedObj.line);

    // set the source code define the shared variable
    selector = "#race" + ord + " .race-var .code-snippet code";
    $(selector).html(convertEscape(race.sharedObj.sourceLine));

    // set the field if there is
    if (race.sharedObj.field) {
        selector = "#race" + ord + " .race-var .structFieldDiv code";
        $(selector).html(" Please check the field " + race.sharedObj.field);
    }
    else {
        selector = "#race" + ord + " .race-var .structFieldDiv";
        $(selector).hide();
    }

    // set the openmp section
    selector = "#race" + ord + " .race-omp";
    if (race.isOmpRace) {
        selector = selector + " .code-snippet code";
        $(selector).html(removeUnnecessaryIdentions(convertEscape(race.ompInfo.snippet)));
    }
    else {
        $(selector).hide();
    }

    setThread(ord, 1, race.access1, race.isOmpRace);
    setThread(ord, 2, race.access2, race.isOmpRace);
}

/**
 * @param race - json
 */
function setupOneAV(ord, race) {
    var selector = "#av" + ord + " .race-no";
    $(selector).html("" + ord);

    // set href to the source file
    selector = "#av" + ord + " .race-var .filepath";
    var el = $(selector);
    // FIXME: disable this for now, since we rarely click this to view source code
    // el.href = "file://" + race.sharedObj.filename;
    el.attr("href", "#av" + ord);
    el.html(race.sharedObj.dir + utils.getFileSep() + race.sharedObj.filename);

    // set line number
    selector = "#av" + ord + " .race-var-src .line-number";
    $(selector).html(race.sharedObj.line);

    // set the source code define the shared variable
    selector = "#av" + ord + " .race-var .code-snippet code";
    $(selector).html(convertEscape(race.sharedObj.sourceLine));

    // set the field if there is
    if (race.sharedObj.field) {
        selector = "#av" + ord + " .race-var .structFieldDiv code";
        $(selector).html(" Please check the field " + race.sharedObj.field);
    }
    else {
        selector = "#av" + ord + " .race-var .structFieldDiv";
        $(selector).hide();
    } 

    setAVThread(ord, 1, race.access1);
    setAVThread(ord, 2, race.access2); 
    setAVThread(ord, 3, race.access3);
}

function setAVThread(raceOrd, accessIndex, jthread) {
    // set source file path
    let selector = "#av" + raceOrd + " .race-threads .race-thread-src" + accessIndex + " .filepath";
    let el = $(selector);
    // FIXME: disable this for now
    // el.href = "file://" + jthread.filename;
    el.attr("href", "#av" + raceOrd);
    el.html(jthread.dir + utils.getFileSep() + jthread.filename);

    // set code snippet
    selector = "#av" + raceOrd + " .race-threads .race-code-snippet" + accessIndex + " code";
    let snippet = removeUnnecessaryIdentions(convertEscape(jthread.snippet))
    $(selector).html(snippet.trimEnd());

    // set stack trace - not very useful. may ask Yanze to generate more deeper trace
    selector = "#av" + raceOrd + " .race-threads .race-stacktrace" + accessIndex + " code";
    if (jthread.stacktrace.length > 0) {
        var str = "";
        var ident = "";
        jthread.stacktrace.forEach(function (line) {
            line = convertEscape(line);
            // convert it to full path
            // delay this to http request
            // so that we can handle loading source code from the server or Github
            // at the same place
            // let firstPath = line.indexOf("[");
            // if (line[firstPath+1] != "/") {
            //     line = line.replace("[", "[" + projectDir + "/");
            // }
            line = convertFilePath(line);
            str += ident + "<span class='make-jeff-happy'><span class='stacktrace-func-name'>" + line + "</span>" + filterToggle + "</span>" + "\n";
            ident += "  ";
        });
        $(selector).html(str);
    }
    else {
        $("#av" + raceOrd + " .race-stacktrace" + accessIndex).hide();
    }
}

// FIXME: this is just a temporary design to make jeff happy
var filterToggle = ' <a id="filterSharedVariableToggle" href="#filterFunction" rel="modal: open" class="filter-function-toggle" >Filter this race</a>'

/**
 * @param raceOrd start from 0
 */
function setThread(raceOrd, threadOrd, jthread, isOmpRace) {
    // set source file path
    let selector = "#race" + raceOrd + " .race-threads .race-thread-src" + threadOrd + " .filepath";
    let el = $(selector);
    // FIXME: disable this for now
    // el.href = "file://" + jthread.filename;
    el.attr("href", "#race" + raceOrd);
    el.html(jthread.dir + utils.getFileSep() + jthread.filename);

    // set code snippet
    selector = "#race" + raceOrd + " .race-threads .race-code-snippet" + threadOrd + " code";
    let snippet = removeUnnecessaryIdentions(convertEscape(jthread.snippet))
    $(selector).html(snippet.trimEnd());

    // set stack trace - not very useful. may ask Yanze to generate more deeper trace
    selector = "#race" + raceOrd + " .race-threads .race-stacktrace" + threadOrd + " code";
    if (jthread.stacktrace.length > 0) {
        var str = "";
        var ident = "";
        jthread.stacktrace.forEach(function (line) {
            line = convertEscape(line);
            str += ident + "<span class='make-jeff-happy'><span class='stacktrace-func-name'>" + line + "</span>" + filterToggle + "</span>" + "\n";
            ident += "  ";
        });
        $(selector).html(str);
    }
    else {
        $("#race" + raceOrd + " .race-stacktrace" + threadOrd).hide();
    }
}


function setupOneMismatchedAPI(ord, race) {
    let prefix = "#mismatchedAPI" + ord
    let selector = prefix + " .race-no";
    $(selector).html("" + ord);

    // set href to the source file
    selector = prefix + " .race-var .filepath";
    var el = $(selector);
    el.attr("href", prefix)
    el.html(race.inst.dir + utils.getFileSep() + race.inst.filename);

    // set line number
    selector = prefix + " .race-var-src .line-number";
    $(selector).html(race.inst.line);

    // set the error message
    selector = prefix + " .race-var-src .explanation";
    $(selector).html(race.errorMsg);

    // set the source code causing the trouble
    // selector = "#mismatchedAPI" + ord + " .source-line code";
    // $(selector).html(race.inst.sourceLine);

    // set the code snippet
    selector = prefix + " .source-snippet code";
    $(selector).html(race.inst.snippet);

    // set the stacktrace
    if (race.inst.stacktrace.length > 0) {
        selector = prefix + " .stacktrace code";
        $(selector).html(utils.formatStacktrace(race.inst.stacktrace));
    } else {
        $("#mismatchedAPI" + ord + " .stacktrace").hide();
    }

    // if this is a re-entrant lock, then we need to add errorMsg2 and inst2
    // having errorMsg2 means this bug also has inst2
    if (race.errorMsg2) {
        selector = prefix + " .error-msg2";
        $(selector).show();
        $(selector).html(utils.preprocessPath(race.errorMsg2));

        selector = prefix + " .inst2-snippet";
        $(selector).show();
        $(selector).find("code").html(race.inst2.snippet);

        if (race.inst2.stacktrace.length > 0) {
            selector = prefix + " .inst2-stacktrace";
            $(selector).show();
            $(selector).find("code").html(utils.formatStacktrace(race.inst2.stacktrace));
        } else {
            $(prefix + " .inst2-stacktrace").hide();
        }
    }
}



function setupBody() {
    var i = 0;
    var raceIdx = 1;
    var html = $("#races").html();

    for (i = 0; i < raceData.dataRaces.length; i++) {
        var html2 = html.replace('race0', 'race' + raceIdx);
        $("#races").append(html2);
        setupOneRace(raceIdx, raceData.dataRaces[i]);
        raceIdx++;
    }

    if (raceData.raceConditions) {
        var avHtml = $("#avs").html();
        for (i = 0; i < raceData.raceConditions.length; i++) {
            var html2 = avHtml.replace('av0', 'av' + raceIdx);
            $("#avs").append(html2);
            setupOneAV(raceIdx, raceData.raceConditions[i]);
            raceIdx++;
        }
    }
    $("#av0").hide();

    for (i = 0; i < raceData.toctou.length; i++) {
        var html2 = html.replace('race0', 'race' + raceIdx);
        $("#races").append(html2);
        setupOneRace(raceIdx, raceData.toctou[i], true);
        raceIdx++;
    }
    $("#race0").hide();

    if (verData.EnableMismatchedAPIs) {
        html = $("#mismatchedAPIs").html();
        for (i = 0; i < raceData.mismatchedAPIs.length; i++) {
            var html2 = html.replace('mismatchedAPI0', 'mismatchedAPI' + raceIdx);
            $("#mismatchedAPIs").append(html2);
            setupOneMismatchedAPI(raceIdx, raceData.mismatchedAPIs[i]);
            raceIdx++;
        }
    }
    else {
        $("#mismatchedAPIs").hide();
    }
    $("#mismatchedAPI0").hide();
}


function setupNavigation() {
    if (typeof comparedWithBase === 'undefined' || !comparedWithBase) {
        $("#viewMode").hide();
        return;
    }

    if (baseGitCommitLog || currGitCommitLog) {
        $("#baseGitCommit").text(baseGitCommitLog);
        $("#currGitCommit").text(currGitCommitLog);
    } else {
        $("#gitCommit").hide();
    }

    $("#fullView").on("click", function (e) {
        let fullView = $(e.target);
        if (fullView.hasClass("selected")) return;
        $(".diff-summary").hide()
        let newView = $("#newView");
        newView.removeClass("selected");
        fullView.addClass("selected");
        // reset report display
        $(".race").show();
        $("#race0").hide();
        $("#av0").hide();
        $(".mismatchedAPI").show();
        $("#mismatchedAPI0").hide();
    });

    $("#newView").on("click", function (e) {
        let newView = $(e.target);
        if (newView.hasClass("selected")) return;

        // diff summary, the total number of new races
        $("#diffSummary").find("#diffRaceNum").text(newDataRaces.length);
        $("#diffSummary").find("#diffMismatchNum").text(newMismatchedAPIs.length);
        $("#diffSummary").find("#diffToctouNum").text(newToctous.length);
        $("#diffSummary").show();

        // diff summary, the anchor to each new races
        // let newRaceList = $("#newRaceList")
        // let idx = 1
        // if (!newRaceList.hasClass("done")) {
        //     var html2;
        //     let html = newRaceList.html();
        //     for (let i = 1; i <= raceData.dataRaces.length; i++) {
        //         html2 = html.replaceAll('race0', 'race' + idx);
        //         newRaceList.append(html2);
        //         idx++;
        //     }

        //     for (let i = 1; i <= raceData.toctou.length; i++) {
        //         html2 = html.replaceAll('race0', 'race' + idx);
        //         newRaceList.append(html2);
        //         idx++;
        //     }

        //     for (let i = 1; i <= raceData.mismatchedAPIs.length; i++) {
        //         html2 = html.replaceAll('race0', 'race' + idx);
        //         newRaceList.append(html2);
        //         idx++;
        //     }
        //     newRaceList.hasClass("done");
        // }

        let fullView = $("#fullView");
        fullView.removeClass("selected");
        newView.addClass("selected");

        // reset race display
        $(".race").show();
        $("#race0").hide();
        $("#av0").hide();
        // hide non-new races
        let idx = 1;
        for (let i = 1; i <= raceData.dataRaces.length; i++) {
            if (newDataRaces.includes(i - 1)) {
                $("#race" + idx).show();
            }
            else {
                $("#race" + idx).hide();
            }
            idx++;
        }

        for (let i = 1; i <= raceData.toctou.length; i++) {
            if (newToctous.includes(i - 1)) {
                $("#race" + idx).show();
            }
            else {
                $("#race" + idx).hide();
            }
            idx++;
        }

        for (let i = 1; i <= raceData.mismatchedAPIs.length; i++) {
            if (newMismatchedAPIs.includes(i - 1)) {
                $("#mismatchedAPI" + idx).show();
            }
            else {
                $("#mismatchedAPI" + idx).hide();
            }
            idx++;
        }
    });
}

function setupFilterOptions() {
    $(".filter-option-item").on("click", function (e) {
        let dom = $(e.currentTarget);
        if (dom.hasClass("selected")) {
            dom.removeClass("selected");
            dom.find("input").prop("checked", false);
        } else {
            dom.addClass("selected");
            dom.find("input").prop("checked", true);
        }
    });
}

function setupScrollTop() {
    $(".go-top").on("click", function () {
        let body = $("body");
        let top = body.scrollTop();

        if (top !== 0) {
            body.animate({ scrollTop: 0 }, 400);
        }
    })
}

var utils = {
    getFileSep: function () {
        let userAgent = window.navigator.userAgent;
        // check windows
        if (userAgent.indexOf("Windows NT") != -1) {
            return "\\";
        } else {
            return "/";
        }
    },

    getRaceNo: function (dom) {
        let id = $(dom).parents(".race").attr("id");
        let re = new RegExp("(?<type>[a-z]+)(?<id>[0-9]+)");
        let groups = id.match(re).groups;
        return {
            type: groups.type,
            no: Number(groups.id)
        };
    },

    getRaceJson: function (dom) {
        let {type, no}  = this.getRaceNo(dom);
        if (type == "av") {
            return raceData.raceConditions[no - 1];
        } else {
            if (no <= raceData.dataRaces.length) {
                return raceData.dataRaces[no - 1]
            } else {
                let idx = no - raceData.dataRaces.length - 1
                return raceData.toctou[idx]
            }
        };
    },

    // reset checkboxes to the default selection
    resetCheckBox: function () {
        $("#sharedVarName").prop("checked", true);
        $("#sharedVarFile").prop("checked", true);
        $("#sharedVarType").prop("checked", false);
        $("#sourceLine").prop("checked", true);
        $("#sourceLineFile").prop("checked", true);
    },

    parseFunction: function (func) {
        // NOTE: split by " [" is a trick
        // because C++ template function names can have space
        func = func.split(" [");
        let funcName = func[0];
        let csFile = func[1].substr(0, func[1].length - 1);
        csFile = csFile.split(":")[0];
        return {
            node: "function",
            name: funcName,
            callsiteSourceFile: csFile
        };
    },

    _keyword: ["static"],

    // strip off the "xxx| " prefix in the source code line
    stripLine: function (line) {
        return line.split("|")[1].trim();
    },

    // This function is supposed to be inaccurate
    // if the raceData contains the name of a shared obj
    // we should use that instead
    parseTypeAndName: function (line, raw_name, ty) {
        let type = ty;
        let name = raw_name;
        // step 1, trim off the prefix (line number and delimiter "|")
        let raw = this.stripLine(line);
        raw = raw.split(" ");
        for (let [idx, s] of raw.entries()) {
            if (this._keyword.includes(s)) continue;
            // the first non-keyword word should be type
            // check if it's a pointer type
            let next = raw[idx + 1];
            if (next) {
                // the number of "*"
                let starNum = next.lastIndexOf("*");
                // type = s + "*".repeat(starNum + 1);
                // FIXME: this is an intentional mistake
                // 1. in C, `*` means pointer, while in glob, `*` is the wild card
                // 2. Since we don't have a field "type" in the JSON report, 
                //    we have to match the type string to the source line. However,
                //    there could be multiple spaces between the type name and the `*`.
                //    For example: 
                //      obj_io *io = calloc(1, sizeof(obj_io));
                //    its type should be `obj_io*`
                //    but you can write it as above (one space), or `obj_io* io`
                // In conclusion, although not distinguishing pointer type is unsound,
                // it is much easier to do so.
                if (!ty || ty === "")
                    type = s;
                if (!name || ty === "")
                    name = next.substr(starNum + 1);
                break
            }
        }
        // console.log("parsing result:")
        // console.log("Type: " + type)
        // console.log("Name: " + name)
        return { type, name }
    },

    formatStacktrace: function (st) {
        var str = "";
        var ident = "";
        st.forEach(function (line) {
            str += ident + line + "\n";
            ident += "  ";
        });
        return str
    },

    // Wrap paths in the string with <code></code>,
    // so that they are displayed in a monospaced way
    // This is a oversimplified way to find path.
    // Later we may need regex to help
    preprocessPath: function (str) {
        let arr = str.split(" ");
        for (let [i, elm] of arr.entries()) {
            if (elm.startsWith("/")) {
                arr[i] = "<code>" + elm + "</code>";
            }
        }
        return arr.join(" ");
    }
}

var filter = {
    // check if to hide the race based on the filter node
    // return `true` if the race is filtered
    // `false` otherwise
    _hideRace: function (race, idx, node) {
        if (node.node === "function") {
            for (let f of race.access1.stacktrace) {
                f = f.split(" [");
                if (f[0].includes(node.name) && f[1].includes(node.callsiteSourceFile)) {
                    console.log("hide race" + idx)
                    $("#race" + idx).hide();
                    return true
                }
            }
            for (let f of race.access2.stacktrace) {
                f = f.split(" [");
                if (f[0].includes(node.name) && f[1].includes(node.callsiteSourceFile)) {
                    console.log("hide race" + idx)
                    $("#race" + idx).hide();
                    return true
                }
            }
        } else if (node.node === "line") {
            // NOTE: Trick here
            // We set the default value of those properties to "".
            // This is because in JS, string.includes("") always return true.
            // So it acts as a wildcard here.
            let code = node.code ? node.code : "";
            let sourceFile = node.sourceFile ? node.sourceFile : "";

            if ((race.access1.sourceLine.includes(code) &&
                race.access1.filename.includes(sourceFile)) ||
                (race.access2.sourceLine.includes(code) &&
                    race.access2.filename.includes(sourceFile))) {
                $("#race" + idx).hide();
                return true;
            }
        } else if (node.node === "variable") {
            let name = node.name ? node.name : "";
            let sourceFile = node.sourceFile ? node.sourceFile : "";
            let type = node.type ? node.type : "";

            // NOTE: this is essentially a bug in core engine
            let sharedObjName =
                race.sharedObj.name ? race.sharedObj.name : utils.parseTypeAndName(race.sharedObj.sourceLine, race.sharedObj.name, race.sharedObj.tyStr).name;

            if (sharedObjName.includes(name) &&
                race.sharedObj.filename.includes(sourceFile) &&
                race.sharedObj.sourceLine.includes(type)) {
                $("#race" + idx).hide();
                return true;
            }
        }
        return false;
    },

    hideFilteredRaces: function (node) {
        let idx = 0
        for (let r of raceData.dataRaces) {
            idx++
            if (r.hidden) {
                console.log("skip hidden race" + idx);
                continue;
            }
            r.hidden = this._hideRace(r, idx, node);
            if (r.hidden == true) {
                console.log("filtered race" + idx);
            }
        }
        for (let tt of raceData.toctou) {
            idx++
            if (tt.hidden) {
                console.log("skip hidden race" + idx);
                continue;
            }
            tt.hidden = this._hideRace(tt, idx, node);
            if (tt.hidden == true) {
                console.log("filtered race" + idx);
            }
        }
    },

    // FIXME: this seems to be overly complex, discuss with Jie
    // check redundancy and add the new properties into filter list
    addNode: function (node) {
        for (let f of this.config.report.filters) {
            if (f.node !== node.node) continue;
            if (node.node === "line") {
                // filtering the same code pattern
                if (node.code === f.code) {
                    // the previous filter is more specific
                    // make it to be a 
                    if (f.sourceFile && !node.sourceFile) {
                        f.sourceFile = node.sourceFile
                    }
                    // the current filter covers more case
                    // no need to add `node` into filter list
                    else if (!f.sourceFile && node.sourceFile) {
                        break;
                    } else {
                        this.config.report.filters.push(node)
                    }
                    break;
                }
            } else if (node.node === "variable") {
            }
        }
        // node doesn't exist in current filter list
        return false;
    },

    // initial empty config
    config: {
        report: {
            filters: []
        }
    },

    // used for redundancy check for function node
    // since our function node is a little different
    addedFunctions: []
}


// main
$(document).ready(function () {
    // set up the report header
    $("#projectName").html(getProjectPath(raceData.bcfile));
    $("#reportGeneratedAt").html(raceData.generatedAt);
    $("#numOfRaces").html(raceData.dataRaces.length
        + raceData.mismatchedAPIs.length
        + raceData.toctou.length);
    $("#coderrectVer").html(verData.Version);

    // set up the navigation bar
    setupNavigation();

    // set up the report body
    setupBody();

    // set up event handler for filter selection
    setupFilterOptions();

    // set up scroll-to-top button
    setupScrollTop();

    $(".race-toggle").on("click", function (e) {
        let dom = $(e.target);
        if (dom.hasClass("race-hide")) {
            dom.removeClass("race-hide")
            dom.addClass("race-show");
            dom.parent().siblings().hide()
        } else {
            dom.removeClass("race-show")
            dom.addClass("race-hide");
            dom.parent().siblings().show()
        }
    })

    $("#feedbackForm").submit(function () {
        $.modal.close();
    });

    // Generate filter list
    $("#createFilter").on("click", function () {
        // write saved config into html
        $("#configJson").html(JSON.stringify(filter.config, null, "  "));
        // highlight it
        $("#config").each(function () {
            hljs.highlightBlock(this);
        });
    })

    $(".filter-var-toggle").on("click", function (e) {
        utils.resetCheckBox();
        let raceJson = utils.getRaceJson(e.target);
        let sharedObj = raceJson.sharedObj;
        let info = utils.parseTypeAndName(sharedObj.sourceLine, sharedObj.name, sharedObj.tyStr);
        let name = sharedObj.name ? sharedObj.name : info.name;
        // NOTE: cautious! here we updated the original race data
        sharedObj.name = name;
        $("#variableNameVal").html(name);
        $("#sourceFileVal").html(sharedObj.filename);
        $("#variableTypeVal").html(info.type);
        // console.log(sharedObj);
    })

    $("#sharedVarSave").on("click", function (e) {
        // first, checking checkbox states
        let nameChecked = $("#sharedVarName").is(":checked");
        let fileChecked = $("#sharedVarFile").is(":checked");
        let typeChecked = $("#sharedVarType").is(":checked");
        // at least one checkbox need to be checked
        if (!(nameChecked || fileChecked || typeChecked)) {
            console.warn("you didn't check anything");
            toastr.error("You must select at least one property to filter");
            return;
        }
        // empty variable node
        let node = { node: "variable" };
        if (nameChecked) {
            node.name = $("#variableNameVal").text();
        }
        if (fileChecked) {
            node.sourceFile = $("#sourceFileVal").text();
        }
        if (typeChecked) {
            node.type = $("#variableTypeVal").text();
        }
        filter.config.report.filters.push(node);
        toastr.success('You just filtered some races from the report. Please click "Create a filter list" to persist the filter list into the configuration file.');
        filter.hideFilteredRaces(node);
    })


    $(".filter-line-toggle").on("click", function (e) {
        utils.resetCheckBox();
        let raceJson = utils.getRaceJson(e.target);
        let access = $(e.target).parents(".code-snippet").hasClass("race-code-snippet1") ? "access1" : "access2";
        let accessJson = raceJson[access];
        $("#sourceLineVal").html(utils.stripLine(accessJson.sourceLine));
        $("#sourceLineFileVal").html(accessJson.filename);
        // console.log(accessJson);
    })

    $("#lineSave").on("click", function () {
        // first, checking checkbox states
        let lineChecked = $("#sourceLine").is(":checked");
        console.log("line checked: " + lineChecked)
        let fileChecked = $("#sourceLineFile").is(":checked");
        console.log("file checked: " + fileChecked)
        // at least one checkbox need to be checked
        if (!(lineChecked || fileChecked)) {
            toastr.error("You must select at least one attribute!");
            console.warn("At least one attribute must be selected to filter source line.");
            return;
        }
        // empty variable node
        let node = { node: "line" };
        if (lineChecked) {
            node.code = $("#sourceLineVal").text();
        }
        if (fileChecked) {
            node.sourceFile = $("#sourceLineFileVal").text();
        }
        filter.config.report.filters.push(node);
        toastr.success('You just filtered some races from the report. Please click "Create a filter list" to persist the filter list into the configuration file.');
        filter.hideFilteredRaces(node);
    })

    // Event handler when user click "Filter this race" in stack trace
    $(".filter-function-toggle").on("click", function (e) {
        // Get the index of the clicked function
        let stIndex = $(e.target).parent().index();
        let raceJson = utils.getRaceJson(e.target);
        let access = $(e.target).parents(".stacktrace").hasClass("race-stacktrace1") ? "access1" : "access2";
        let accessJson = raceJson[access];
        let func = accessJson.stacktrace[stIndex];
        let node = utils.parseFunction(func)

        let confirmed = window.confirm('Are you sure to filter races calling "' + node.name + '" from the report?')
        if (!confirmed) return;

        // NOTE: maybe we shouldn't use `func` to check redundancy
        // because func has line number associated
        // only use function name + callsite file is more reasonable
        // However, since we will hide filtered races immediately,
        // this is not very necessary for now
        if (filter.addedFunctions.includes(func)) {
            toastr.warning("This function is already in the filter list.")
            console.warn("function already added to the filter list");
            return;
        }
        filter.addedFunctions.push(func);
        filter.hideFilteredRaces(node)
        // debugging
        // console.log(access);
        // console.log(raceJson[access]);
        // console.log(func);
        // console.log(funcName);
        // console.log(csFile);
        filter.config.report.filters.push(node);
        // debugging
        // console.log(console.log(JSON.stringify(filter.config, null, "  ")));
        toastr.success('You just filtered some races from the report. Please click "Create a filter list" to persist the filter list into the configuration file.')
    })

    // Set up code editor
    // reference: https://stackoverflow.com/questions/57048510/how-to-initialize-microsoft-monaco-editor-in-a-browser-using-simple-javascript-o
    require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@latest/min/vs' }});
    window.MonacoEnvironment = { getWorkerUrl: () => proxy };

    let proxy = URL.createObjectURL(new Blob([`
        self.MonacoEnvironment = {
            baseUrl: 'https://unpkg.com/monaco-editor@latest/min/'
        };
        importScripts('https://unpkg.com/monaco-editor@latest/min/vs/base/worker/workerMain.js');
    `], { type: 'text/javascript' }));

    // FIXME: this should be configured by the reporter
    axios.defaults.baseURL = "http://localhost:8887";
    require(["vs/editor/editor.main"], function () {
        let editor = monaco.editor.create(document.getElementById('editor'), {
            value: [
                "fn say() { println!(\"hello\"); }"
            ].join('\n'),
            language: 'rust',
            theme: 'vs-dark'
        });
        // TODO: for now, only enable it on avs
        $("#avs .filepath").on("click", function(e) {
            let rawpath = e.target.innerText;
            let [filepath, ...rest] = rawpath.split(":");
            var fromGithub = false;
            if (currentGitUrl) {
                if (filepath.startsWith(projectDir))
                    filepath = filepath.replace(projectDir, "");
                filepath = currentGitUrl + filepath;
                requestPath = encodeURI(filepath);
                fromGithub = true;
            } else {
                if (!filepath.startsWith(projectDir))
                    filepath = projectDir + filepath;
                requestPath = "/api/v1/files/pull?filepath=" + encodeURIComponent(filepath);
            }
            var lineno = 0;
            if (rest.length > 0) {
                lineno = Number(rest[0]);
            }
            // let encoded = encodeURIComponent(filepath);
            axios.get(requestPath)
                .then(function (resp) {
                    if (fromGithub)
                        editor.setValue(resp.data);
                    else
                        editor.setValue(resp.data["code"]);
                    $("#vs").modal();
                    editor.layout();
                    editor.revealLineInCenterIfOutsideViewport(lineno);
                })
                .catch(function (err) {
                    console.log(err);
                });
        });
    });
});
