<?xml version="1.0" encoding="iso-2022-jp"?>
<!DOCTYPE modulesynopsis SYSTEM "../style/modulesynopsis.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.ja.xsl"?>
<modulesynopsis metafile="mpm_common.xml.meta">
<!-- English revision: 1.21 -->

<name>mpm_common</name>
<description>二つ以上のマルチプロセッシングモジュール (MPM)
で実装されているディレクティブのコレクション</description>
<status>MPM</status>

<directivesynopsis>
<name>CoreDumpDirectory</name>
<description>Apache がコアダンプする前に移動を試みるディレクトリ
</description>
<syntax>CoreDumpDirectory <var>directory</var></syntax>
<default>デフォルトの設定は説明文を読んでください</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module><module>mpm_winnt</module>
</modulelist>

<usage>

    <p>Apache がコアダンプする前に移動を試みるディレクトリを制御します。
    デフォルト値は <directive module="core">ServerRoot</directive>
    ディレクトリですが、このディレクトリはサーバの実行されているユーザ権限で
    書き込み可能であるべきではないので、通常はコアダンプは書き込まれません。
    デバッグのためにコアダンプが必要であれば、
    このディレクティブを使って他の位置にコアダンプを書き出すようにできます。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>Group</name>
<description>リクエストに応答する際に所属するグループ</description>
<syntax>Group <var>unix-group</var></syntax>
<default>Group #-1</default>
<contextlist><context>server config</context>
<context>virtual host</context>
</contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module></modulelist>

<usage>
    <p><directive>Group</directive> ディレクティブで、
    リクエストに応答する際に所属しておくグループを設定します。
    このディレクティブを使用するためには、スタンドアロン型の
    サーバは最初に root 権限で起動されている必要があります。
    <var>unix-group</var> は次のうちのいずれかです:</p>

    <dl>
      <dt>グループ名</dt>

      <dd>グループを名前で参照します。</dd>

      <dt># に続いてグループ番号</dt>

      <dd>グループを番号で参照します。</dd>
    </dl>
    <p>サーバを実行するために特定の新しいグループを設定することを
    お薦めします。<code>nobody</code> を使用する管理者もいますが、
    これは常に可能であったり望ましい訳ではありません。</p>

    <example>Group www-group</example>

    <p>注意: サーバ開始を非 root ユーザで行った場合は、
    指定されたグループに変わることができなくて、代わりに
    起動を行ったユーザの所属するグループとして実行され続けます。</p>

    <p>特記事項: このディレクティブを &lt;VirtualHost&gt;
    で使用することはサポートされなくなりました。Apache 2.0 で
    <a href="../suexec.html">suEXEC ラッパー</a>を実現したい場合は、
    <directive module="mod_suexec">SuexecUserGroup</directive>
    を使用してください。
    セキュリティ: セキュリティ上の注意点に関しては、
    <directive module="mpm_common">User</directive>
    をご覧下さい。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>PidFile</name>
<description>デーモンのプロセス ID
をサーバが記録するためのファイル</description>
<syntax>PidFile <var>filename</var></syntax>
<default>PidFile logs/httpd.pid</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module><module>mpm_winnt</module>
</modulelist>

<usage>
    <p><directive>PidFile</directive> ディレクティブで、
    デーモンのプロセス ID をサーバが記録するファイルを設定します。
    もしファイル名がスラッシュ (/) で始まらない場合は、
    <directive module="core">ServerRoot</directive>
    からの相対的なものとして扱われます。</p>

    <example><title>例</title>
    PidFile /var/run/apache.pid
    </example>

    <p>サーバが <directive module="core">ErrorLog</directive>
    や TransferLog を閉じて開き直したり、設定ファイルを
    再読込したりさせるために、サーバにシグナルを送ることができると
    便利なことがあります。
    これは SIGHUP (kill -1) シグナルを PidFile
    に書かれているプロセス ID に送ることでできます。</p>

    <p>PidFile には、ログファイルの設置位置や
    <a href="../misc/security_tips.html#serverroot">セキュリティ</a>
    と全く同じ注意点があります。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>Listen</name>
<description>サーバが listen するIP アドレスとポート番号</description>
<syntax>Listen [<var>IP-address</var>:]<var>portnumber</var></syntax>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module><module>mpm_winnt</module>
</modulelist>

<usage>
    <p><directive>Listen</directive> ディレクティブは Apache
    が特定の IP アドレスやポート番号だけを listen するように指定します。
    デフォルトでは全ての IP インターフェースのリクエストに応答します。
    Listen ディレクティブは現在では必須のディレクティブとなりました。
    もし設定ファイルになければ、サーバは起動に失敗します。
    これは以前のバージョンの Apache から変更のあった部分です。</p>

    <p>Listen ディレクティブでは、特定のポートあるいは
    アドレスとポートの組み合わせから入ってくるリクエストに対して
    応答するように指定します。
    もしポート番号だけが指定された場合は、サーバは全インターフェースの
    指定されたポート番号に対して listen します。
    IP アドレスがポートとともに指定された場合は、
    サーバは指定されたポートとインターフェースに対して listen 
    します。</p>

    <p>複数のアドレスとポートに対して listen するように、
    複数の Listen ディレクティブを使うこともできます。
    サーバは列挙されたアドレスとポート全てからのリクエストに対して
    応答します。</p>

    <p>例えば、サーバが 80 番ポートと 8000 番ポートの両方の
    コネクションを受け入れる場合は、次のようにします。</p>

    <example>
       Listen 80<br />
       Listen 8000
    </example>

    <p>二つの特定のインターフェースとポート番号からのコネクションを
    受け入れるようにするには、次のようにします。</p>

    <example>
       Listen 192.170.2.1:80<br />
       Listen 192.170.2.5:8000
    </example>

    <p>IPv6 アドレスは角括弧で囲まなければなりません。
    例えば次の例のようにです。</p>

    <example>
       Listen [fe80::a00:20ff:fea7:ccea]:80
    </example>
</usage>

<seealso><a href="../dns-caveats.html">DNS の問題</a></seealso>
<seealso><a href="../bind.html">Apache
    が使用するアドレスとポートの設定</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ListenBackLog</name>
<description>保留状態のコネクションのキューの最大長</description>
<syntax>ListenBacklog <var>backlog</var></syntax>
<default>ListenBacklog 511</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module><module>mpm_winnt</module>
</modulelist>

<usage>
    <p>保留状態のコネクションのキューの最大長です。
    一般的には調整する必要はありませんし、調整は望ましくありません。
    しかし、TCP SYN フラッドアタックの状況下におかれる場合に、
    増やした方が望ましいシステムもあります。
    <code>listen(2)</code> システムコールのバックログパラメータを
    ご覧下さい。</p>

    <p>この値は OS により、小さな数に抑えられます。
    値は OS 毎に異なっています。また多くの OS では、
    バックログとして指定されている値ちょうどまで使っているわけではなく、
    設定されている値に基づいて (通常は設定値よりも大きな値を)
    使っていることに注意してください。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>LockFile</name>
<description>受付を直列化するためのロックファイルの位置</description>
<syntax>LockFile <var>filename</var></syntax>
<default>LockFile logs/accept.lock</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module></modulelist>

<usage>
    <p>USE_FCNTL_SERIALIZED_ACCEPT または USE_FLOCK_SERIALIZED_ACCEPT
    のいずれかを使って Apache をコンパイルした際に使用することになる、
    ロックファイルのパスを <directive>LockFile</directive>
    は設定します。
    このディレクティブは通常はデフォルト値のままにしておくべきです。
    これを変更する際の主な理由は、<code>logs</code>
    ディレクトリが NFS マウントされたものであるという理由です。
    <strong>ロックファイルはローカルディスクに保存しなければならない
    からです。</strong>
    メインサーバプロセスの PID が自動的にファイル名に付加されます。</p>

    <note type="warning"><title>セキュリティ:</title>
    <p><code>/var/tmp</code>
    といった、誰でも書き込めるディレクトリにファイルを
    置かない方がよいです。なぜなら、サーバが起動時に作成する
    ロックファイルの作成自体を妨害することによって、
    誰でもサービス拒否アタックを引き起こすことができるからです。</p>
    </note>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>MaxClients</name>
<description>リクエストに応答するために作成される
子プロセスの最大個数</description>
<syntax>MaxClients <var>number</var></syntax>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>prefork</module>
</modulelist>

<usage>
    <p><directive>MaxClients</directive> ディレクティブは、
    応答することのできる同時リクエスト数を設定します。
    <directive>MaxClients</directive> 制限数を越えるコネクションは通常、
    <directive module="mpm_common">ListenBacklog</directive>
    ディレクティブで設定した数までキューに入ります。
    他のリクエストの最後まで達して子プロセスが空くと、
    次のコネクションに応答します。</p>

    <p>スレッドを用いないサーバ (すなわち <module>prefork</module>)
    では、<directive>MaxClients</directive>
    は、リクエストに応答するために起動される
    子プロセスの最大数となります。
    デフォルト値は 256 で、これを増加させたい場合は、
    <directive module="mpm_common">ServerLimit</directive>
    の値も増加させる必要があります。</p>

    <p>スレッドを用いるサーバ (すなわち <module>worker</module>)
    では、<directive>MaxClients</directive> 
    は、クライアントに応答できるスレッドの総数を制限します。
    デフォルト値は
    <directive module="mpm_common">ThreadsPerChild</directive>
    を 16 倍した値になります。<directive>MaxClients</directive>
    を 16 プロセス以上必要な値まで増加させたい場合は、
    <directive module="mpm_common">ServerLimit</directive>
    も増加させる必要があります。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>MaxMemFree</name>
<description>主メモリアロケータが free() を呼ばずに保持し続けられるメモリの
最大量</description>
<syntax>MaxMemFree <var>number</var></syntax>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>prefork</module>
<module>mpm_netware</module>
</modulelist>

<usage>
    <p><directive>MaxMemFree</directive> ディレクティブは free() を呼ばずに
    主アロケータが保持できる空のメモリの最大値をキロバイト単位で設定します。
    設定されていないか、零に設定されているときは、無制限になります。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>MaxRequestsPerChild</name>
<description>個々の子サーバが稼働中に扱うリクエスト数の上限</description>
<syntax>MaxRequestsPerChild <var>number</var></syntax>
<default>MaxRequestsPerChild 10000</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module><module>mpm_winnt</module>
</modulelist>

<usage>
    <p><directive>MaxRequestsPerChild</directive> ディレクティブは、
    個々の子サーバプロセスが扱うことのできるリクエストの制限数を
    設定します。<directive>MaxRequestsPerChild</directive>
    個のリクエストの後に、子プロセスは終了します。
    <directive>MaxRequestsPerChild</directive> が 0
    に設定されている場合は、プロセスは期限切れにより終了することはありません。</p>

    <p><directive>MaxRequestsPerChild</directive>
    を非ゼロに制限することには、二つの利点があります:</p>

    <ul>
      <li>(偶発的な) メモリーリークが起こった場合に
      プロセスが消費するメモリの総量を制限できる</li>

      <li>プロセスに有限のライフタイムを設定することで、
      サーバ負荷が下がった時にプロセス数を少なくすることができる</li>
    </ul>

    <note><title>注意:</title>
    <p><em>KeepAlive</em> リクエストの場合は、
    一つ目のリクエストだけがこの制限に該当します。
    実効的には、一つの子プロセスあたりの<em>コネクション</em>数を
    制限するように挙動が変化します。</p>
    </note>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>MaxSpareThreads</name>
<description>アイドルスレッドの最大数</description>
<syntax>MaxSpareThreads <var>number</var></syntax>
<contextlist><context>server config</context></contextlist>
<modulelist><module>mpm_netware</module>
<module>perchild</module><module>worker</module>
</modulelist>

<usage>
    <p>アイドルなスレッドの最大数です。異なる MPM ではそれぞれ、
    このディレクティブは異なる取り扱われ方をされます。</p>

    <p><module>perchild</module> では、
    デフォルトは <code>MaxSpareThreads 10</code> です。
    この MPM はアイドルスレッド数を、それぞれの子プロセスごとに監視します。
    子プロセスにアイドルスレッドが多すぎる場合は、
    サーバはその子プロセスに含まれるスレッドを終了し始めます。</p>

    <p><module>worker</module> では、
    デフォルトは <code>MaxSpareThreads 500</code> です。
    この MPM はアイドルスレッド数をサーバ全体で監視します。
    サーバでアイドルスレッド数が多すぎる場合は、
    この数字よりも少ない数になるまで子プロセスを終了します。</p>

    <p><module>mpm_netware</module> では、
    デフォルトは <code>MaxSpareThreads 100</code> です。
    この MPM はシングルプロセスで実行されますので、
    スペアスレッド数もサーバ全体で勘定します。</p>

</usage>
<seealso><directive module="mpm_common">MinSpareThreads</directive></seealso>
<seealso><directive module="mpm_common">StartServers</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>MaxThreadsPerChild</name>
<description>子プロセス毎のスレッド数の最大数</description>
<syntax>MaxThreadsPerChild <var>number</var></syntax>
<default>MaxThreadsPerChild 64</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
</modulelist>

<usage>
    <p>子プロセス毎に含まれるスレッド数の最大値です。
    子プロセス毎にスレッド数変化する MPM では、
    このディレクティブは、子プロセス内に生成されるスレッド数の
    最大値を設定します。デフォルト値よりも大きい値にするのであれば、
    コンパイル時に定義された <code>HARD_THREAD_LIMIT</code>
    を変更して、サーバを再コンパイルする必要があります。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>MinSpareThreads</name>
<description>リクエストに応答することのできる
アイドルスレッド数の最小数</description>
<syntax>MinSpareServers <var>number</var></syntax>
<contextlist><context>server config</context></contextlist>
<modulelist><module>mpm_netware</module>
<module>perchild</module><module>worker</module>      
</modulelist>

<usage>
    <p>リクエストに応答するスレッド数の最小値です。
    異なる MPM ではそれぞれ、
    このディレクティブは異なる取り扱われ方をします。</p>

    <p><module>perchild</module> では、
    デフォルトは <code>MinSpareThreads 5</code> で、
    アイドルスレッド数を子プロセス毎に監視します。
    もし子プロセスに十分な数のスレッドがなければ、
    サーバはその子プロセスに新しいスレッドを作り始めます。</p>

    <p><module>worker</module> では、
    デフォルトは <code>MinSpareThreads 250</code> で、
    アイドルスレッド数をサーバ全体で監視します。
    もしサーバに十分な数のアイドルスレッドがなければ、
    アイドルスレッド数がこの数よりも大きくなるまで
    新しい子プロセスが生成されます。</p>

    <p><module>mpm_netware</module> では、
    デフォルトは <code>MinSpareThreads 10</code> で、
    シングルプロセス MPM ですので、サーバ全体で管理されます。</p>

</usage>
<seealso><directive module="mpm_common">MaxSpareThreads</directive></seealso>
<seealso><directive module="mpm_common">StartServers</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>NumServers</name>
<description>同時に起動している子プロセスの総数</description>
<syntax>NumServers <var>number</var></syntax>
<default>NumServers 2</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>perchild</module></modulelist>

<usage>
    <p>同時に起動している子プロセスの数です。
    このディレクティブを使用する MPM は動的に新しい子プロセスを
    生成することは行わないので、サイト全体に来るリクエスト全てを
    十分扱える程度に大きな数に設定しておく必要があります。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>ScoreBoardFile</name>
<description>子プロセスと連携するためのデータを保存する
ファイルの位置</description>
<syntax>ScoreBoardFile <var>file-path</var></syntax>
<default>ScoreBoardFile logs/apache_status</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module></modulelist>

<usage>
    <p>Apache は親プロセスと子プロセス間の通信にスコアボードを用います。
    この通信機能にファイルを必要とするアーキテクチャもあります。
    ファイルが指定されていなければ、Apache はまずメモリ上
    (匿名共有メモリ) にスコアボードを作ろうとし、それが失敗すると
    ディスク上にファイル (ファイルベースの共有メモリ) を作ろうとします。
    このディレクティブを指定すると、Apache
    は必ずディスクにファイルを生成します。</p>

    <example><title>例</title>
      ScoreBoardFile /var/run/apache_status
    </example>

    <p>ファイルベースの共有メモリは、サードパーティー製のアプリケーションで
    スコアボードに直接アクセスする必要がある場合に役に立ちます。</p>

    <p><directive>ScoreBoardFile</directive> を使う場合、
    RAM ディスク上に置くとスピードが向上するでしょう。
    しかし、ログファイルの設置位置や
    <a href="../misc/security_tips.html">セキュリティ</a>
    と同様の注意点があるので、注意してください。</p>
</usage>
<seealso><a
    href="../stopping.html">Apache の停止と再起動</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>SendBufferSize</name>
<description>TCP バッファサイズ</description>
<syntax>SendBufferSize <var>bytes</var></syntax>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module><module>mpm_winnt</module>
</modulelist>

<usage>
    <p>サーバは TCP バッファサイズを指定されたバイト数に設定します。
    高速で高レイテンシな環境で
    (<em>例</em> 100ms 程度、大陸横断高速通信路など)
    古い一般的な OS のデフォルト値を増やすのに非常に便利です。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>ServerLimit</name>
<description>設定可能なサーバプロセス数の上限</description>
<syntax>ServerLimit <var>number</var></syntax>
<default>ServerLimit 256 (prefork), ServerLimit 16 (worker)</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>prefork</module>
</modulelist>

<usage>
    <p><module>prefork</module> MPM の場合は、このディレクティブは
    Apache プロセス稼働中における
    <directive module="mpm_common">MaxClients</directive>
    に設定可能な上限値を設定することになります
    (訳注: prefork の場合は同時クライアント数 = サーバプロセス数なので) 。
    <module>worker</module> MPM の場合には、このディレクティブは
    <directive module="mpm_common">ThreadLimit</directive>
    ディレクティブと組み合わせて、
    Apache プロセス稼働中における
    <directive module="mpm_common">MaxClients</directive>
    に設定可能な上限値を設定することになります。
    再起動中にこのディレクティブを変更しても無視されますが、
    <directive module="mpm_common">MaxClients</directive>
    は再起動中に修正することができます。</p>

    <p>このディレクティブを使用する際は特に注意してください。
    <directive>ServerLimit</directive> が必要以上に大きな値に
    設定された場合は、余計な未使用共有メモリが割り当てられます。
    <directive>ServerLimit</directive> と
    <directive module="mpm_common">MaxClients</directive>
    がシステムの扱える範囲を越えた設定値になっていると、
    Apache は起動しないか、起動しても不安定になるでしょう。</p>

    <p><module>prefork</module> MPM では、
    <directive module="mpm_common">MaxClients</directive>
    を 256 よりも大きな値に設定する必要がある時にだけ使用してください。
    希望の <directive module="mpm_common">MaxClients</directive>
    数とくらべて、必要以上に大きな値を指定することは避けてください。</p>

    <p><module>worker</module> MPM では、
    <directive module="mpm_common">MaxClients</directive> と
    <directive module="mpm_common">ThreadsPerChild</directive>
    の設定で 16 サーバプロセス以上必要になる場合にのみ使用してください。
    希望の
    <directive module="mpm_common">MaxClients </directive> と
    <directive module="mpm_common">ThreadsPerChild</directive>
    とくらべて、必要となるサーバプロセス数以上に大きな値を
    設定することは避けてください。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>StartServers</name>
<description>起動時に生成される子サーバプロセスの数</description>
<syntax>StartServers <var>number</var></syntax>
<default>StartServers 5</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module></modulelist>

<usage>
    <p><directive>StartServers</directive> ディレクティブは、
    起動時に生成される子サーバプロセスの数を設定します。
    プロセス数は負荷に応じて動的に制御されますので、
    通常はこの値を調整する理由はあまりないでしょう。</p>
</usage>
<seealso><directive module="mpm_common">MinSpareThreads</directive></seealso>
<seealso><directive module="mpm_common">MaxSpareThreads</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>StartThreads</name>
<description>起動時に生成されるスレッドの数</description>
<syntax>StartThreads <var>number</var></syntax>
<contextlist><context>server config</context></contextlist>
<modulelist><module>mpm_netware</module><module>perchild</module></modulelist>

<usage>
    <p>起動時に生成されるスレッドの数です。
    スレッド数は負荷に応じて動的に制御されますので、
    通常はこの値を調整する理由はあまりないでしょう。</p>

    <p><module>perchild</module> でのデフォルトは
    <code>StartThreads 5</code> で、このディレクティブは起動時に
    プロセス毎のスレッド数を追跡します。</p>

    <p><module>mpm_netware</module> でのデフォルトは
    <code>StartThreads 50</code> で、
    この場合プロセスは一つしかないので、
    起動時にリクエストに応答するスレッドの総数となります。</p>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>ThreadLimit</name>
<description>設定可能な子プロセス毎のスレッド数の上限を
設定します</description>
<syntax>ThreadLimit <var>number</var></syntax>
<contextlist><context>server config</context></contextlist>
<modulelist><module>mpm_winnt</module><module>worker</module></modulelist>

<usage>
    <p>このディレクティブは
    Apache プロセス稼働中における
    <directive module="mpm_common">ThreadsPerChild</directive>
    に設定可能な上限値を設定します。再起動時にこのディレクティブの値を
    変更しても無視されますが、
    <directive module="mpm_common">ThreadsPerChild</directive>
    は再起動中に、このディレクティブで指定された上限値まで
    変更することができます。</p>

    <p>このディレクティブを使用する際は特に注意してください。
    <directive>ThreadLimit</directive> が
    <directive module="mpm_common">ThreadsPerChild</directive>
    よりもずっと大きな値に設定された場合は、
    余計な未使用共有メモリが割り当てられてしまいます。
    <directive>ThreadLimit</directive> が
    <directive module="mpm_common">ThreadsPerChild</directive>
    の両方がシステムの扱える範囲を超えている場合は、
    Apache は起動しないか、起動したとしても不安定になるでしょう。
    このディレクティブの値は今使用している Apache の <directive
    module="mpm_common">ThreadsPerChild</directive> の予想上限値を
    超えた値には設定しないでください。
    </p>

    <p><directive>ThreadLimit</directive> のデフォルト値は
    <module>worker</module> のときは 64 で、<module>mpm_winnt</module> のときは
    1920 です。</p>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>ThreadsPerChild</name>
<description>子プロセスそれぞれに生成されるスレッド数</description>
<syntax>ThreadsPerChild <var>number</var></syntax>
<default>ThreadsPerChild 50</default>
<contextlist><context>server config</context></contextlist>
<modulelist><module>worker</module><module>mpm_winnt</module>
</modulelist>

<usage>
    <p>このディレクティブは、それぞれの子プロセスで生成される
    スレッド数を設定します。
    子プロセスは開始時にこれらのスレッドを生成して、
    その後は生成しません。<module>mpm_winnt</module> のような、
    子プロセスが一つしかないような MPM を利用しているのであれば、
    この値はサーバの負荷全体を十分取り扱える程度に、
    大きくなければなりません。<module>worker</module> のような、
    子プロセスが複数あるような MPM を利用しているのであれば、
    サーバの通常負荷を十分扱える程度に、
    スレッド総数が多くなければなりません。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>User</name>
<description>リクエストに応答する際に用いるユーザ ID</description>
<syntax>User <var>unix-userid</var></syntax>
<default>User #-1</default>
<contextlist><context>server config</context>
<context>virtual host</context>
</contextlist>
<modulelist><module>worker</module><module>perchild</module>
<module>prefork</module></modulelist>

<usage>
    <p><directive>User</directive> ディレクティブは
    サーバがリクエストに応答する際に用いるユーザ ID を設定します。
    このディレクティブを使用するためには、スタンドアロン型の
    サーバは最初に root 権限で起動されている必要があります。
    <var>unix-userid</var> は次のどちらかです:</p>

    <dl>
      <dt>ユーザ名</dt>

      <dd>ユーザを名前で参照します。</dd>

      <dt># に続いてユーザ番号</dt>

      <dd>ユーザを番号で参照します。</dd>
    </dl>

    <p>このユーザは、外部に見せるように意図していないファイルに、
    アクセス可能になってしまうような権限を持つべきではないですし、
    同様に httpd リクエストに対して応答するように意図していない
    実行コードを、実行できるような権限を持つべきではないです。
    サーバを実行するために特定の新しいユーザとグループを
    設定することをお薦めいたします。
    <code>nobody</code> ユーザを使用する管理者もいますが、
    これが常に望ましいわけではありません。
    なぜなら <code>nobody</code> ユーザは、システムで
    他の役割を担っているかも知れないからです。</p>

    <p>注意: 非 root ユーザでサーバを起動した場合は、
    より低い権限のユーザに変わることに失敗して、
    代わりに起動を行ったユーザ権限のまま実行され続けるでしょう。
    root 権限で開始した場合親プロセスが root
    権限で実行され続けますが、これは正常です。</p>

    <p>特記事項: このディレクティブを
    <directive module="core" type="section">VirtualHost</directive>
    で使用することはサポートされなくなりました。
    <a href="mod_suexec.html">suexec</a> 向けにサーバを設定するのであれば、
    <directive module="mod_suexec">SuexecUserGroup</directive>
    を使用してください。</p>

<note><title>セキュリティ</title>
<p>自分が何をやっているのか正確に把握していない、
そしてその危険性を把握していないのであれば、
<directive>User</directive>
(や <directive module="mpm_common">Group</directive>)
を <code>root</code> に設定しないでください。</p></note>
</usage>
</directivesynopsis>

</modulesynopsis>
